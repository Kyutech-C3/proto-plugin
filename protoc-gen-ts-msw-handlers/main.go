package main

import (
	"fmt"
	"math/rand"
	"protoc-gen-ts-msw-handlers/utils"
	"strings"

	option "google.golang.org/genproto/googleapis/api/annotations"
	"google.golang.org/protobuf/compiler/protogen"
	"google.golang.org/protobuf/proto"
	"google.golang.org/protobuf/reflect/protoreflect"
)

func main() {
	protogen.Options{}.Run(func(gen *protogen.Plugin) error {
		generatedFiles := []string{}
		handlerNames := []string{}
		for _, protoFile := range gen.Files {
			if !protoFile.Generate {
				continue
			}
			for _, service := range protoFile.Services {
				fileName, handlerName := serviceToHandler(gen, service)
				if handlerName != "" {
					generatedFiles = append(generatedFiles, fileName)
					handlerNames = append(handlerNames, handlerName)
				}
			}
		}
		g := gen.NewGeneratedFile("types/index.ts", "")
		for _, protoFile := range gen.Files {
			if strings.Contains(*protoFile.Proto.Name, "third_party") || strings.Contains(*protoFile.Proto.Name, "google") {
				continue
			}
			for _, enum := range protoFile.Enums {
				enumToType(g, enum)
			}
			for _, message := range protoFile.Messages {
				messageToType(g, message)
			}
		}
		exportAsOneVariable(gen.NewGeneratedFile("handlers.ts", ""), generatedFiles, handlerNames)

		return nil
	})
}

func exportAsOneVariable(g *protogen.GeneratedFile, fileNames []string, handlerNames []string) {
	for i, fileName := range fileNames {
		g.P("import { ", handlerNames[i], "Handlers } from './", fileName, "'")
	}
	g.P("export const handlers = [")
	for _, handlerName := range handlerNames {
		g.P("  ...", handlerName, "Handlers,")
	}
	g.P("]")

}

func serviceToHandler(gen *protogen.Plugin, service *protogen.Service) (string, string) {
	filename := "handlers/" + service.GoName + "/handlers.ts"
	handlerName := ""
	g := gen.NewGeneratedFile(filename, "")
	g.P("/* eslint-disable */")
	g.P("/* This file is generated by protoc-gen-ts-msw-handlers */")
	g.P("/* Do not edit this file manually */")
	g.P("import { http, HttpResponse } from 'msw'")
	handlerName = generateService(g, service)
	return filename, handlerName
}

func generateService(g *protogen.GeneratedFile, service *protogen.Service) string {
	generatedMethodNames := []string{}
	for _, method := range service.Methods {
		methodName := generateMethod(g, method)
		if methodName != "" {
			generatedMethodNames = append(generatedMethodNames, methodName)
		}
	}
	g.P("export const ", utils.ToLowerCamelCase(service.GoName), "Handlers = [")
	for _, methodName := range generatedMethodNames {
		g.P("  ", methodName, ",")
	}
	g.P("]")
	return utils.ToLowerCamelCase(service.GoName)
}

func generateMethod(g *protogen.GeneratedFile, method *protogen.Method) string {
	options := method.Desc.Options()
	apiMethod, path := getPathAndMethod(proto.GetExtension(options, option.E_Http).(*option.HttpRule))
	if path != "" {
		methodName := getHandlerName(path, apiMethod)
		g.P("const ", methodName, " = http.", apiMethod, "(", "'", path, "'", ",() => {")
		g.P("  return HttpResponse.json({")
		for _, field := range method.Output.Fields {
			GenerateField(g, field)
		}
		g.P("  })")
		g.P("})")
		return methodName
	}
	return ""
}

func GenerateField(g *protogen.GeneratedFile, field interface{}) {
	switch v := field.(type) {
	case *protogen.Field:
		if v.Desc.Message() != nil {
			if v.Desc.IsList() {
				g.P("    ", utils.UpperCamelToSnake(v.Desc.JSONName()), ":", "[")
				for i := 0; i < rand.Intn(10); i++ {
					g.P("    {")
					for i := 0; i < v.Desc.Message().Fields().Len(); i++ {
						if v.Desc.Message().Fields().Get(i).HasPresence() {
							a := v.Desc.Message().Fields().Get(i).Message().Fields()
							g.P("    ", utils.UpperCamelToSnake(v.Desc.Message().Fields().Get(i).JSONName()), ":{")
							GenerateField(g, a)
							g.P("    },")
						} else {

							g.P("    ", utils.UpperCamelToSnake(v.Desc.Message().Fields().Get(i).JSONName()), ":", "'", utils.MockGenerator(utils.UpperCamelToSnake(v.Desc.Message().Fields().Get(i).JSONName()), v.Desc.Message().Fields().Get(i).Kind().String()), "'", ",")
						}
					}
					g.P("    },")

				}
				g.P("    ],")

			} else {
				g.P("    ", utils.UpperCamelToSnake(v.Desc.JSONName()), ":", "{")
				for i := 0; i < v.Desc.Message().Fields().Len(); i++ {
					if v.Desc.Message().Fields().Get(i).HasPresence() {
						a := v.Desc.Message().Fields().Get(i).Message().Fields()
						g.P("    ", utils.UpperCamelToSnake(v.Desc.Message().Fields().Get(i).JSONName()), ":{")
						GenerateField(g, a)
						g.P("    },")
					} else {

						g.P("    ", utils.UpperCamelToSnake(v.Desc.Message().Fields().Get(i).JSONName()), ":", "'", utils.MockGenerator(utils.UpperCamelToSnake(v.Desc.Message().Fields().Get(i).JSONName()), v.Desc.Message().Fields().Get(i).Kind().String()), "'", ",")
					}
				}
				g.P("    },")
			}
		} else {

			g.P("    ", utils.UpperCamelToSnake(v.Desc.JSONName()), ":", "'", utils.MockGenerator(utils.UpperCamelToSnake(v.Desc.JSONName()), v.Desc.Kind().String()), "'", ",")
		}
	case protoreflect.FieldDescriptors:
		for i := 0; i < v.Len(); i++ {
			if v.Get(i).HasPresence() {

				g.P(v.Get(i).Name(), ":{")
				GenerateField(g, v.Get(i).Message().Fields())
				g.P("},")
			} else {

				g.P("    ", utils.UpperCamelToSnake(string(v.Get(i).Name())), ":", "'", utils.MockGenerator(utils.UpperCamelToSnake(v.Get(i).JSONName()), v.Get(i).Kind().String()), "'", ",")

			}
		}
	default:
		fmt.Println("message")
	}
}

func getHandlerName(path string, method string) string {
	return pathToMethodName(path) + utils.ToUpperCamelCase(method) + "Handler"
}

func messageToType(g *protogen.GeneratedFile, message *protogen.Message) {

	g.P("export type ", message.GoIdent.GoName, " = {")
	for _, field := range message.Fields {
		if field.Desc.Message() != nil {
			listContext := ""
			if field.Desc.IsList() {
				listContext = "[]"
			}
			g.P("  ", utils.ToLowerCamelCase(field.GoName), ": ", field.Desc.Message().Name(), listContext, ";")
		} else if field.Desc.Enum() != nil {
			g.P("  ", utils.ToLowerCamelCase(field.GoName), ": ", field.Desc.Enum().Name(), ";")
		} else {
			g.P("  ", utils.ToLowerCamelCase(field.GoName), ": ", utils.TypeConvert(field.Desc.Kind().String()), ";")
		}
	}
	g.P("}")
}

func enumToType(g *protogen.GeneratedFile, enum *protogen.Enum) {
	enumContext := ""
	for _, value := range enum.Values {
		enumContext += "'" + string(value.Desc.Name()) + "'" + " | "
	}
	g.P("export type ", enum.GoIdent.GoName, " = ", enumContext[:len(enumContext)-2], ";")
}

func getPathAndMethod(rule *option.HttpRule) (string, string) {
	if rule.GetGet() != "" {
		return "get", rule.GetGet()
	}
	if rule.GetPost() != "" {
		return "post", rule.GetPost()
	}
	if rule.GetPut() != "" {
		return "put", rule.GetPut()
	}
	if rule.GetDelete() != "" {
		return "delete", rule.GetDelete()
	}
	if rule.GetPatch() != "" {
		return "patch", rule.GetPatch()
	}
	return "get", ""
}

func removeUselessString(s string) string {
	return strings.ReplaceAll(strings.ReplaceAll(strings.ReplaceAll(strings.ReplaceAll(s, "{", ""), "}", ""), "@", ""), "-", "")
}

func pathToMethodName(path string) string {
	if path == "" {
		return ""
	}
	split := strings.Split(path, "/")
	uppers := []string{}
	for _, s := range split {
		uppers = append(uppers, (utils.ToUpperCamelCase(utils.SnakeToCamel(removeUselessString(s)))))
	}
	return strings.Join(uppers, "")
}
