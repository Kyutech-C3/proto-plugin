package main

import (
	"protoc-gen-ts-msw-handlers/utils"
	"strings"

	openapiOption "github.com/grpc-ecosystem/grpc-gateway/v2/protoc-gen-openapiv2/options"
	option "google.golang.org/genproto/googleapis/api/annotations"
	"google.golang.org/protobuf/compiler/protogen"
	"google.golang.org/protobuf/proto"
)

func main() {
	protogen.Options{}.Run(func(gen *protogen.Plugin) error {
		for _, protoFile := range gen.Files {
			if !protoFile.Generate {
				continue
			}
			serviceToHandler(gen, protoFile)
			messageToType(gen, protoFile)
		}
		return nil
	})
}

func serviceToHandler(gen *protogen.Plugin, protoFile *protogen.File) {
	filename := protoFile.GeneratedFilenamePrefix + "/handlers.ts"
	g := gen.NewGeneratedFile(filename, "")
	g.P("/* eslint-disable */")
	g.P("/* This file is generated by protoc-gen-ts-msw-handlers */")
	g.P("/* Do not edit this file manually */")
	g.P("import { http, HttpResponse } from 'msw'")
	for _, service := range protoFile.Services {
		generateService(g, service)
	}
}

func generateService(g *protogen.GeneratedFile, service *protogen.Service) {
	for _, method := range service.Methods {
		generateMethod(g, method)
	}
}

func generateMethod(g *protogen.GeneratedFile, method *protogen.Method) {
	options := method.Desc.Options()
	apiMethod, path := getPathAndMethod(proto.GetExtension(options, option.E_Http).(*option.HttpRule))
	if path != "" {
		g.P("export const ", getHandlerName(path, apiMethod), " = http.", apiMethod, "(", "'", path, "'", ",() => {")
		g.P("  return new HttpResponse.json({")
		for _, field := range method.Output.Fields {
			bodyOption := field.Desc.Message().Options()
			openapiv2Value := proto.GetExtension(bodyOption, openapiOption.E_Openapiv2Schema).(*openapiOption.Schema)
			g.P("    ", utils.ToLowerCamelCase(field.GoName), ": ", listContext(field, openapiv2Value.Example), ",")
		}
		g.P("  })")
		g.P("})")
	}
}

func getHandlerName(path string, method string) string {
	return pathToMethodName(path) + utils.ToUpperCamelCase(method) + "Handler"
}

func listContext(field *protogen.Field, value string) string {
	if field.Desc.IsList() {
		return "[" + value + "]"
	}
	return value
}

func messageToType(gen *protogen.Plugin, protoFile *protogen.File) {
	g := gen.NewGeneratedFile(protoFile.GeneratedFilenamePrefix+"/types.ts", "")
	for _, message := range protoFile.Messages {

		g.P("export type ", message.GoIdent.GoName, " = {")
		for _, field := range message.Fields {
			if field.Desc.Message() != nil {
				g.P("  ", utils.ToLowerCamelCase(field.GoName), ": ", field.Desc.Message().Name(), ";")
			} else {
				g.P("  ", utils.ToLowerCamelCase(field.GoName), ": ", utils.TypeConvert(field.Desc.Kind().String()), ";")
			}
		}
		g.P("}")
	}
}

func getPathAndMethod(rule *option.HttpRule) (string, string) {
	if rule.GetGet() != "" {
		return "get", rule.GetGet()
	}
	if rule.GetPost() != "" {
		return "post", rule.GetPost()
	}
	if rule.GetPut() != "" {
		return "put", rule.GetPut()
	}
	if rule.GetDelete() != "" {
		return "delete", rule.GetDelete()
	}
	if rule.GetPatch() != "" {
		return "patch", rule.GetPatch()
	}
	return "get", ""
}

func pathToMethodName(path string) string {
	if path == "" {
		return ""
	}
	split := strings.Split(path, "/")
	uppers := []string{}
	for _, s := range split {
		uppers = append(uppers, utils.ToUpperCamelCase(s))
	}
	return strings.Join(uppers, "")
}
